Kubernets (https://kubernetes.io/):

Cada nó no cluster deve ter pelo menos 300MB de memória. https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/
Cada nó kubernetes (https://kubernetes.io/docs/concepts/architecture/nodes/) executa:
	- Kubelet, implementa o api dos pods e do próprio nó
	- Container runtime, e.g. Docker
	- Kube Proxy, cria um ip virtual para aceder aos pods que executam no nó


Docker Swarm (https://docs.docker.com/engine/swarm/):

Cada nó docker swarm (https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/) executa o Docker Engine.
Não consegui encontrar nenhuma informação sobre o uso de memória de um docker swarm node. O docker stats apenas dá informação sobre as métricas de containers.


Kubernetes vs Docker Swarm:

As funcionalidades do docker swarm usadas atualmente são as básicas:
swarm init
swarm join
swarm leave
O comportamento do swarm é feito manualmente, com a replicação, migração, etc, de containers a ser feita com comandos manuais após ser detetada a sua necessidade, o que depende das métricas obtidas, e da configuração e do estado do sistema.

Portanto, existe a possibilidade de usar apenas as funcionalidades básicas do kubernetes para criar/gerir o cluster e iniciar/gerir os componentes istio.


Service Registry vs Istio:

O service mesh tem muitas mais funcionalidades do que apenas a descoberta de serviços. Mas, se apenas for usada essa funcionalidade do service mesh, apenas é necessário ter a executar o Istio Pilot que gere a descoberta de serviços, e o Istio Service-api que substitui o Service-api do kubernetes. O Istio Pilot pode executar apenas em nós na cloud, enquanto que nos nós na edge executam os microserviços juntamente com os sidecard proxies. Sempre que é adicionado um novo pod a um nó, os componentes pilot são notificados, e por sua vez atualizam todos os sidecard proxies no cluster.


Istio com docker:

Se for decidido que o kubernetes não é adequado, o istio também funciona, embora limitado, em ambientes docker + consul service registry. Mas os sidecars têm que ser configurados e adicionados manualmente. https://github.com/istio/istio/blob/master/samples/bookinfo/platform/consul/templates/bookinfo.sidecars.yaml.tmpl


Próximo exercicio:

1. Simular uma máquina cloud k8s ao executar um k8s master node com os componentes do istio necessários.
2. Simular uma máquina cloud docker ao executar um docker swarm master node com o service registry eureka.

3. Simular uma máquina edge (aws ec2) k8s ao executar um k8s worker node com um container de um microserviço + um container injetado do sidecar proxy.
4. Simular uma máquina edge (aws ec2) docker ao executar um docker swarm node com um container de um microserviço + um container do componente de descoberta.

5. Comparar a utilização de recursos das máquinas k8s vs máquinas docker.



Na altura de escolher entre o kubernetes e o docker swarm, foram considerados os seguintes pontos:


	Pontos a favor do kubernetes:

	1. O kubernetes é uma ferramenta de orquestração de containers fortemente apoiada pela comunidade. Qualquer sistema que rivalize com o kubernetes irá ter uma adoção dificil por parte da comunidade.

	2. Muitas ferramentas cloud, como o Istio, focam-se em garantir a execução correta num ambiente kubernetes, deixando outros ambientes de execução um pouco esquecidos.
	
	
	Pontos a favor do docker swarm:

	1. A instalação do kubernetes é dificil e lenta. Mesmo versões leves do kubernetes, como o microk8s, o minikube, ou o k3s (https://k3s.io/), usam muitos dos recursos das máquinas na edge que, supostamente, devem ter uma capacidade muito reduzida (0.5/1/2GB RAM, 2/4 CPUs).

	2. As versões leves do kubernetes (microk8s, minikube, k3s, kind, etc) devem ser apenas usadas numa máquina local, de modo a configurar um ambiente kubernetes para aprendizagem (https://kubernetes.io/docs/setup/#learning-environment). Por exemplo, o microk8s não aborda certos problemas de segurança, caso a máquina seja pública (https://microk8s.io/docs/ports).
	Para configurar um ambiente de produção (https://kubernetes.io/docs/setup/#production-environment), seria preciso haver uma dependência a um provider, que gerisse parte do ambiente (data plane, control plane, cluster infrastructure)

	3. Os componentes que estão atualmente em desenvolvimento (monitorização leve, replicação/migração base de dados, etc), usam o docker swarm, e estão a ser desenvolvidos para serem integrados neste sistema. O uso do kubernetes inviabiliza a integração desses componentes no sistema.



kubernetes master requer no minimo 2 cpus para iniciar

Máquina (n1-standard-1 (1 vCPUj, 3,75 GB de memória)) com istio pilot a executar num ambiente docker:
525MB ram ocupada (free -m)
4-5% cpu usado (google cloud monitoring)

A mesma máquina com a aplicação demo bookinfo (https://github.com/istio/istio/tree/master/samples/bookinfo) a executar:
1100MB ram ocupada (free -m)
8-10% cpu usado (google cloud monitoring)