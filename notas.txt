Comandos executados no ubuntu 18.04

------------------------ Preparação do ambiente de trabalho ------------------------

--------- Java ---------

. Instalar o java 11 jdk
	sudo apt-get install openjdk-11-jdk
	java -version

--------- Maven ---------

. Instalar o maven
	sudo apt install maven
	mvn --version

--------- Intellij ---------
https://www.jetbrains.com/help/idea/installation-guide.html?section=Windows

. Instalar o jetbrains toolbox
	Abrir https://www.jetbrains.com/toolbox/download/download-thanks.html no browser
	tar xvf jetbrains-toolbox-*.tar.gz
	sudo rm -rf jetbrains-toolbox-*.tar.gz
	sudo mv jetbrains-toolbox-*/jetbrains-toolbox /usr/local/bin/
	sudo rm -rf jetbrains-toolbox-*

. Instalar o Intellij
	jetbrains-toolbox
	Instalar o Intellij IDEA Ultimate ou Community a partir do toolbox

. Instalar o lombok plugin
	No Intellij, File -> Settings -> Plugins -> Procurar lombok -> Instalar -> Reiniciar o Intellij

--------- SSH ---------

. Instalar o ssh
	sudo apt install openssh-server
	sudo systemctl status ssh

. Testar uma ligação 
	ssh username@localhost

--------- Docker ---------
https://docs.docker.com/engine/api/v1.24/
https://success.docker.com/article/how-do-i-enable-the-remote-api-for-dockerd

. Configurar o Docker
	sh Microservices\ management\ main\ components/replication-migration/src/main/resources/scripts/docker-install.sh

--------- Kubernets ---------

. Instalar o kubectl
	curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
	chmod +x kubectl
	sudo mv kubectl /usr/local/bin/kubectl
	kubectl version

> minikube
https://kubernetes.io/docs/tasks/tools/install-minikube/

	. Instalar um hypervisor, virtualbox ou kvm (dependência opcional. embora limitado, o minikube pode executar sem uma vm)
		wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
		sudo add-apt-repository "deb [arch=amd64] http://download.virtualbox.org/virtualbox/debian $(lsb_release -cs) contrib"
		sudo apt update
		sudo apt install virtualbox-6.0
		vboxmanage --version

	. Instalar o minikube
		curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
		chmod +x minikube
  		sudo install minikube /usr/local/bin
  		sudo rm minikube
  		minikube version

	. Hello World 
		https://kubernetes.io/docs/tutorials/hello-minikube/

--------- Istio ---------
https://istio.io/docs/setup/kubernetes/getting-started/

. Preparar o minikube

	minikube delete
	minikube start --memory=16384 --cpus=4
	minikube ssh
	top
	ctrl+c
	exit
	minikube tunnel (num novo terminal, loadbalancer opcional)
	
. Obter a última release do Istio
	curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.2.2 sh -
	cd isto-*/
	export PATH=$PWD/bin:$PATH
	https://istio.io/docs/ops/setup/istioctl/#istioctl-auto-completion

. Instalar todos os Custom Resource Definitions (CRDs) do Istio
	for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done

. Instalar o profile demo
	kubectl apply -f install/kubernetes/istio-demo.yaml

. Verificar que os kubernetes services estão ativos
	kubectl get svc -n istio-system

. Verificar que os kubernetes pods estão ativos e a executar
	kubectl get pods -n istio-system

> Experimentar executar a app Bookinfo no minikube
https://istio.io/docs/examples/bookinfo/#deploying-the-application

	. Ativar a injeção automática dos proxies como sidecars
		kubectl label namespace default istio-injection=enabled

	. Iniciar a aplicação demo bookinfo
		kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml

	. Verificar que os serviços estão ativos
		kubectl get services

	. Verificar que os pods estão ativos e a executar
		kubectl get pods

	. Verificar que a aplicação está a executar
		kubectl exec -it $(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}') -c ratings -- curl productpage:9080/productpage | grep -o "<title>.*</title>"

	. Tornar a aplicação acessivel de fora do kubernetes cluster, usando um istio gateway
		kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml

	. Verificar que o gateway está ativo e a executar
		kubectl get gateway

	. Ver qual o host e porta onde está a executar o gateway
		https://istio.io/docs/tasks/traffic-management/ingress/ingress-control/#determining-the-ingress-ip-and-ports
		kubectl get svc istio-ingressgateway -n istio-system
		Se o external-port estiver pending ou não existir:
			export INGRESS_HOST=$(minikube ip)
			export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].nodePort}')
		Se tiver external-port:
			export INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
			export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].port}')

	. Definir o url do gateway
		export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT

	. Verificar se o microserviço está acessivel fora do cluster
		curl -s http://${GATEWAY_URL}/productpage | grep -o "<title>.*</title>"

	. Aplicar o routing baseado na versão do Bookinfo
		kubectl apply -f samples/bookinfo/networking/destination-rule-all.yaml

	. Exercicio: Aplicar regras de routing para apenas a versão 1 da aplicação
		kubectl apply -f samples/bookinfo/networking/virtual-service-all-v1.yaml 
		kubectl get virtualservices -o yaml
		kubectl get destinationrules -o yaml
		curl -s http://${GATEWAY_URL}/productpage (nunca mostra o rating da review porque é versão 1)

	. Exercicio: Aplicar regras de routing baseado no utilizador

	. Desinstalar o bookinfo
		samples/bookinfo/platform/kube/cleanup.sh

------------------------ Comandos úteis ------------------------

> Geral

. Abrir o explorador de ficheiros no caminho atual do terminal
	xdg-open .

. Mudar o proprietário de um ficheiro/diretoria para o user atual
	sudo chown -R $USER {path}

. Mudar a versão java
	sudo update-alternatives --config java

> Replication Migration

. Diretoria
	cd Dissertação/Código/Microservices\ management\ main\ components/replication-migration/

. Executar localmente
	Alterar os EdgeHosts no ficheiro de base de dados data.sql para incluir o pc onde se executa localmente
	mvn -DskipTests package && sudo java -jar ./target/managerMaster-0.0.1.jar --dockerMaster=192.168.1.76

. Se a executar bloquear no 'Generating random seed from SecureRandom', instalar rng-tools
	sudo apt install rng-tools

> Docker

. Parar os containers do docker
	docker stop $(docker ps -a -q)

. Remover os containers do docker
	docker rm $(docker ps -a -q)

> AWS

. Fazer uma conexão à máquina ec2
	ssh -i /home/daniel/Dissertação/Código/Microservices\ management\ main\ components/replication-migration/src/main/resources/aws/ec2.pem ubuntu@ec2-{IP}.us-east-2.compute.amazonaws.com

> Google cloud

gcloud auth login
gcloud config set project PROJECT_ID
gcloud container clusters get-credentials your-first-cluster-1 --zone us-central1-a --project PROJECT_ID
gcloud compute ssh INSTANCE_ID

. Permitir VMs dentro da máquina google
gcloud compute images create nested-vm-image --source-disk isto-1  --source-disk-zone us-central1-a --licenses "https://www.googleapis.com/compute/v1/projects/vm-options/global/licenses/enable-vmx"

> Minikube

kubectl config use-context minikube

minikube config set cpus 4
minikube config set memory 8192
minikube config set disk-size 50g
minikube addons enable ingress 
minikube start


> VNC 
Na máquina a ser controlada:
	sudo apt-get install ubuntu-desktop
	sudo apt-get install xinit
	startx
Na máquina a controlar:

------------------------ TODO List ------------------------
> Replication-migration: Alterar todas as variaveis de portas para int
> Replication-migration: Alterar os system outs para log usando @Slf4j do lombok
> Replication-migration: MUdar o genericResponse para nao ser uma lista
> Componentes Java: Alterar para java 11
> Documentação: Adicionar java docs e go docs https://blog.golang.org/godoc-documenting-go-code
> CLI: Desenvolver um CLI para interagir com os componentes e estado do sistema
> Testes: adicionar unit tests ao máximo de código possivel
> Web: Remover o jquery